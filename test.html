<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebXR AR with Plane Detection & GLB Loading</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>

      <!-- ç¶²é ç”¨Console -->
  <script src="https://cdn.bootcdn.net/ajax/libs/vConsole/3.15.0/vconsole.min.js"></script>
  <script>  var vConsole = new VConsole();  </script>
  </head>
  <body style="margin:0; padding:0; overflow:hidden; background:#000;">
    <div id="ui" style="position: absolute; top: 20px; left: 20px; right: 20px; z-index: 999;">
      <button id="startAR" style="width: 100%; padding: 20px; font-size: 20px; background: #4CAF50; color: white; border: none; border-radius: 10px; cursor: pointer;">
        å•Ÿå‹• AR
      </button>
      
      <div style="margin-top: 10px; display: flex; gap: 10px;">
        <input type="file" id="modelUpload" accept=".glb,.gltf" style="display: none;">
        <button id="uploadBtn" style="flex: 1; padding: 15px; font-size: 16px; background: #2196F3; color: white; border: none; border-radius: 8px;">
          ä¸Šå‚³ GLB æ¨¡å‹
        </button>
        <button id="resetBtn" style="flex: 1; padding: 15px; font-size: 16px; background: #ff9800; color: white; border: none; border-radius: 8px;">
          æ¸…é™¤æ‰€æœ‰ç‰©ä»¶
        </button>
      </div>
      
      <div id="status" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.8); color: white; border-radius: 10px; font-family: Arial, sans-serif; font-size: 14px;">
        æº–å‚™æ¸¬è©¦ WebXR AR...
      </div>
      
      <div id="instructions" style="margin-top: 10px; padding: 10px; background: rgba(0,100,200,0.7); color: white; border-radius: 8px; font-family: Arial, sans-serif; font-size: 13px;">
        ğŸ“± èªªæ˜ï¼šé»æ“Šåµæ¸¬åˆ°çš„å¹³é¢ä¾†æ”¾ç½® 3D ç‰©ä»¶
      </div>
      
      <div id="debug" style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.6); color: #ccc; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto;">
        <div>WebXR AR é™¤éŒ¯:</div>
      </div>
    </div>

    <canvas id="canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>

    <script>
      const startBtn = document.getElementById('startAR');
      const uploadBtn = document.getElementById('uploadBtn');
      const resetBtn = document.getElementById('resetBtn');
      const modelUpload = document.getElementById('modelUpload');
      const status = document.getElementById('status');
      const debug = document.getElementById('debug');
      const canvas = document.getElementById('canvas');
      
      let gl, xrSession, hitTestSource;
      let scene, camera, renderer, reticle;
      let animationFrameId;
      let referenceSpace = null;
      let referenceSpaceAttempted = false;
      
      // æ¨¡å‹ç›¸é—œ
      //ks
      let currentModel = null;
      let placedObjects = [];
      let loader = new THREE.GLTFLoader();
      let defaultModelUrl = 'src\model\test.glb'; // é è¨­æ¨¡å‹æª”æ¡ˆå
      
      // å¹³é¢åµæ¸¬ç›¸é—œ
      let detectedPlanes = [];
      let planeMeshes = [];
      
      function updateStatus(msg) {
        status.textContent = msg;
        addDebug('Status: ' + msg);
      }
      
      function addDebug(msg) {
        const div = document.createElement('div');
        div.textContent = new Date().toLocaleTimeString() + ': ' + msg;
        debug.appendChild(div);
        debug.scrollTop = debug.scrollHeight;
        console.log('[AR]', msg);
        
        if (debug.children.length > 30) {
          debug.removeChild(debug.children[1]);
        }
      }
      
      async function loadModel(url) {
        // å‹•æ…‹è¼‰å…¥ GLTFLoader
        if (!loader) {
          addDebug('è¼‰å…¥ GLTFLoader...');
          await loadGLTFLoader();
        }
        
        return new Promise((resolve, reject) => {
          addDebug('è¼‰å…¥æ¨¡å‹: ' + url);
          loader.load(
            url,
            (gltf) => {
              addDebug('æ¨¡å‹è¼‰å…¥æˆåŠŸ');
              const model = gltf.scene;
              
              // èª¿æ•´æ¨¡å‹å¤§å°å’Œä½ç½®
              const box = new THREE.Box3().setFromObject(model);
              const size = box.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              const scale = 0.2 / maxDim; // èª¿æ•´ç‚ºåˆé©å¤§å°
              model.scale.setScalar(scale);
              
              // å°‡æ¨¡å‹ç½®ä¸­
              const center = box.getCenter(new THREE.Vector3());
              model.position.sub(center.multiplyScalar(scale));
              
              resolve(model);
            },
            (progress) => {
              const percent = Math.round((progress.loaded / progress.total) * 100);
              addDebug(`è¼‰å…¥é€²åº¦: ${percent}%`);
            },
            (error) => {
              addDebug('æ¨¡å‹è¼‰å…¥å¤±æ•—: ' + error.message);
              reject(error);
            }
          );
        });
      }
      
      // å‹•æ…‹è¼‰å…¥ GLTFLoader
      function loadGLTFLoader() {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js';
          script.onload = () => {
            if (THREE.GLTFLoader) {
              loader = new THREE.GLTFLoader();
              addDebug('GLTFLoader è¼‰å…¥æˆåŠŸ');
              resolve();
            } else {
              reject(new Error('GLTFLoader è¼‰å…¥å¤±æ•—'));
            }
          };
          script.onerror = () => reject(new Error('ç„¡æ³•è¼‰å…¥ GLTFLoader è…³æœ¬'));
          document.head.appendChild(script);
        });
      }
      
      function createReticle() {
        const geometry = new THREE.RingGeometry(0.02, 0.04, 32);
        const material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.8
        });
        reticle = new THREE.Mesh(geometry, material);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);
        addDebug('æº–æ˜Ÿå‰µå»ºå®Œæˆ');
      }
      
      function createDefaultCube() {
        const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshLambertMaterial({ 
          color: 0xff4444,
          transparent: true,
          opacity: 0.8
        });
        const cube = new THREE.Mesh(geometry, material);
        return cube;
      }
      
      async function initThreeJS() {
        addDebug('å‰µå»º XR å…¼å®¹çš„ Three.js ç’°å¢ƒ...');
        
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        
        const contextAttributes = {
          alpha: true,
          antialias: true,
          xrCompatible: true
        };
        
        gl = canvas.getContext('webgl', contextAttributes) || canvas.getContext('experimental-webgl', contextAttributes);
        
        if (!gl) {
          throw new Error('ç„¡æ³•å‰µå»º WebGL ä¸Šä¸‹æ–‡');
        }
        
        addDebug('WebGL ä¸Šä¸‹æ–‡å·²å‰µå»º (xrCompatible: true)');
        
        renderer = new THREE.WebGLRenderer({ 
          canvas: canvas,
          context: gl,
          alpha: true,
          antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // æ·»åŠ å…‰æº
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // å‰µå»ºæº–æ˜Ÿ
        createReticle();
        
        // å˜—è©¦è¼‰å…¥é è¨­æ¨¡å‹
        try {
          currentModel = await loadModel(defaultModelUrl);
          addDebug('é è¨­æ¨¡å‹è¼‰å…¥æˆåŠŸ');
        } catch (error) {
          addDebug('é è¨­æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨é è¨­ç«‹æ–¹é«”');
          currentModel = createDefaultCube();
        }
        
        addDebug('Three.js XR å…¼å®¹åˆå§‹åŒ–å®Œæˆ');
      }
      
      async function startAR() {
        try {
          updateStatus('æª¢æŸ¥ WebXR æ”¯æ´...');
          startBtn.disabled = true;
          
          if (!navigator.xr) {
            throw new Error('WebXR ä¸æ”¯æ´');
          }
          
          const supported = await navigator.xr.isSessionSupported('immersive-ar');
          if (!supported) {
            throw new Error('è¨­å‚™ä¸æ”¯æ´ AR');
          }
          
          if (gl && !gl.isXRCompatible) {
            addDebug('å°‡ä¸Šä¸‹æ–‡æ¨™è¨˜ç‚º XR å…¼å®¹...');
            await gl.makeXRCompatible();
          }
          
          addDebug('è«‹æ±‚ AR æœƒè©± (åŒ…å«å¹³é¢åµæ¸¬)...');
          updateStatus('å•Ÿå‹• AR æœƒè©±...');
          
          xrSession = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['local'],
            optionalFeatures: ['plane-detection', 'hit-test']
          });
          addDebug('AR æœƒè©±å‰µå»ºæˆåŠŸ');
          
          const glLayer = new XRWebGLLayer(xrSession, gl);
          await xrSession.updateRenderState({ baseLayer: glLayer });
          
          xrSession.addEventListener('end', cleanup);
          
          // ç²å–åƒè€ƒç©ºé–“
          referenceSpace = await xrSession.requestReferenceSpace('local');
          addDebug('ç²å–åƒè€ƒç©ºé–“æˆåŠŸ');
          
          // è¨­ç½® hit test
          try {
            hitTestSource = await xrSession.requestHitTestSource({ space: referenceSpace });
            addDebug('Hit test è¨­ç½®æˆåŠŸ');
          } catch (error) {
            addDebug('Hit test è¨­ç½®å¤±æ•—: ' + error.message);
          }
          
          updateStatus('AR å•Ÿå‹•æˆåŠŸï¼é»æ“Šå¹³é¢æ”¾ç½®ç‰©ä»¶');
          animationFrameId = xrSession.requestAnimationFrame(onXRFrame);
          
          // æ·»åŠ é»æ“Šäº‹ä»¶
          canvas.addEventListener('click', onTouch);
          
          setTimeout(() => {
            document.getElementById('ui').style.display = 'none';
          }, 4000);
          
        } catch (error) {
          updateStatus('AR å•Ÿå‹•å¤±æ•—: ' + error.message);
          addDebug('è©³ç´°éŒ¯èª¤: ' + error.toString());
          startBtn.disabled = false;
        }
      }
      
      function onTouch(event) {
        if (!xrSession || !reticle.visible) return;
        
        if (currentModel) {
          const modelClone = currentModel.clone();
          modelClone.position.copy(reticle.position);
          modelClone.rotation.copy(reticle.rotation);
          
          // éš¨æ©ŸåŒ–é¡è‰² (å¦‚æœæ˜¯é è¨­ç«‹æ–¹é«”)
          if (modelClone.material && modelClone.material.color) {
            modelClone.material = modelClone.material.clone();
            modelClone.material.color.setHSL(Math.random(), 0.8, 0.6);
          }
          
          scene.add(modelClone);
          placedObjects.push(modelClone);
          
          addDebug(`æ”¾ç½®ç‰©ä»¶ #${placedObjects.length} åœ¨ (${reticle.position.x.toFixed(2)}, ${reticle.position.y.toFixed(2)}, ${reticle.position.z.toFixed(2)})`);
        }
      }
      
      function onXRFrame(time, frame) {
        if (!xrSession) return;
        
        animationFrameId = xrSession.requestAnimationFrame(onXRFrame);
        
        const pose = frame.getViewerPose(referenceSpace);
        
        if (pose) {
          // Hit test for reticle positioning
          if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              reticle.visible = true;
              reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
          
          // è™•ç†å¹³é¢åµæ¸¬
          if (frame.detectedPlanes) {
            updateDetectedPlanes(frame.detectedPlanes);
          }
          
          // æ¸²æŸ“æ¯å€‹è¦–åœ–
          for (const view of pose.views) {
            const viewport = xrSession.renderState.baseLayer.getViewport(view);
            renderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
            
            camera.projectionMatrix.fromArray(view.projectionMatrix);
            camera.matrix.fromArray(view.transform.inverse.matrix);
            camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
            camera.updateMatrixWorld(true);
            
            renderer.clear();
            renderer.render(scene, camera);
          }
        }
      }
      
      function updateDetectedPlanes(detectedPlanes) {
        // æ¸…é™¤èˆŠçš„å¹³é¢ç¶²æ ¼
        planeMeshes.forEach(mesh => scene.remove(mesh));
        planeMeshes = [];
        
        // ç‚ºæ¯å€‹åµæ¸¬åˆ°çš„å¹³é¢å‰µå»ºè¦–è¦ºåŒ–ç¶²æ ¼
        detectedPlanes.forEach((plane, index) => {
          const geometry = new THREE.PlaneGeometry(1, 1);
          const material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.1,
            wireframe: true
          });
          const planeMesh = new THREE.Mesh(geometry, material);
          
          // è¨­ç½®å¹³é¢ä½ç½®å’Œæ—‹è½‰
          const pose = plane.planeSpace.getOffsetReferenceSpace(referenceSpace);
          planeMesh.matrix.fromArray(pose.transform.matrix);
          planeMesh.matrixAutoUpdate = false;
          
          scene.add(planeMesh);
          planeMeshes.push(planeMesh);
        });
      }
      
      function resetObjects() {
        placedObjects.forEach(obj => scene.remove(obj));
        placedObjects = [];
        addDebug('å·²æ¸…é™¤æ‰€æœ‰æ”¾ç½®çš„ç‰©ä»¶');
        updateStatus('ç‰©ä»¶å·²æ¸…é™¤');
      }
      
      function cleanup() {
        if (animationFrameId) {
          xrSession?.cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        
        if (hitTestSource) {
          hitTestSource.cancel();
          hitTestSource = null;
        }
        
        canvas.removeEventListener('click', onTouch);
        
        xrSession = null;
        referenceSpace = null;
        referenceSpaceAttempted = false;
        
        startBtn.disabled = false;
        startBtn.textContent = 'é‡æ–°å•Ÿå‹• AR';
        document.getElementById('ui').style.display = 'block';
        updateStatus('AR æœƒè©±å·²çµæŸ');
      }
      
      // äº‹ä»¶ç›£è½
      startBtn.addEventListener('click', startAR);
      resetBtn.addEventListener('click', resetObjects);
      
      uploadBtn.addEventListener('click', () => {
        modelUpload.click();
      });
      
      modelUpload.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (file) {
          try {
            await waitForGLTFLoader();
            const url = URL.createObjectURL(file);
            currentModel = await loadModel(url);
            addDebug('è‡ªè¨‚æ¨¡å‹è¼‰å…¥æˆåŠŸ: ' + file.name);
            URL.revokeObjectURL(url);
          } catch (error) {
            addDebug('è‡ªè¨‚æ¨¡å‹è¼‰å…¥å¤±æ•—: ' + error.message);
            alert('æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ ¼å¼');
          }
        }
      });
      
      // åˆå§‹åŒ–
      window.addEventListener('load', async () => {
        addDebug('é é¢è¼‰å…¥ï¼Œåˆå§‹åŒ– WebXR AR ç’°å¢ƒ');
        addDebug('User Agent: ' + navigator.userAgent.substring(0, 50) + '...');
        
        try {
          await initThreeJS();
          updateStatus('AR ç’°å¢ƒæº–å‚™å°±ç·’');
        } catch (error) {
          updateStatus('åˆå§‹åŒ–å¤±æ•—: ' + error.message);
          addDebug('åˆå§‹åŒ–éŒ¯èª¤: ' + error.toString());
        }
      });
      
      window.addEventListener('resize', () => {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
      
    </script>
  </body>
</html>