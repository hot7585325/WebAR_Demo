<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Manual WebXR AR with HitTest v2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- vConsole -->
    <script src="https://unpkg.com/vconsole@3.15.1/dist/vconsole.min.js"></script>
  </head>
  <body style="margin:0; padding:0; overflow:hidden; background:#000;">

    <!-- 版本號 -->
    <div id="version" style="position:absolute; top:5px; left:5px; z-index:9999; 
         background:rgba(0,0,0,0.6); color:#0f0; padding:4px 8px; font-size:12px; border-radius:4px; font-family:monospace;">
      v2
    </div>

    <!-- UI -->
    <div id="ui" style="position: absolute; top: 30px; left: 20px; right: 20px; z-index: 999;">
      <button id="startAR" style="width: 100%; padding: 20px; font-size: 20px; background: #4CAF50; color: white; border: none; border-radius: 10px; cursor: pointer;">
        啟動 AR
      </button>
      
      <div id="status" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.8); color: white; border-radius: 10px; font-family: Arial, sans-serif; font-size: 14px;">
        準備中...
      </div>
    </div>

    <canvas id="canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>

    <script>
      // 啟用 vConsole
      new VConsole();

      const startBtn = document.getElementById('startAR');
      const status = document.getElementById('status');
      const canvas = document.getElementById('canvas');
      
      let gl, xrSession, renderer, scene, camera;
      let referenceSpace, hitTestSource;
      let cube = null, reticle = null;

      function log(msg, data) {
        console.log('[AR]', msg, data || '');
        status.textContent = msg;
      }

      async function initThree() {
        log('初始化 Three.js 場景');

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        const contextAttributes = { alpha: true, antialias: true, xrCompatible: true };
        gl = canvas.getContext('webgl', contextAttributes);

        renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          context: gl,
          alpha: true,
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // 光源
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        // reticle 提示 (圓盤)
        const ringGeo = new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7 });
        reticle = new THREE.Mesh(ringGeo, ringMat);
        reticle.visible = false;
        scene.add(reticle);

        log('Three.js 初始化完成');
      }

      async function startAR() {
        try {
          log('檢查 WebXR 支援中...');
          if (!navigator.xr) throw new Error('WebXR 不支援');

          const supported = await navigator.xr.isSessionSupported('immersive-ar');
          if (!supported) throw new Error('設備不支援 AR');

          log('請求 XR Session');
          xrSession = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['hit-test', 'local'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          });

          xrSession.addEventListener('end', () => log('XR Session 結束'));
          xrSession.addEventListener('select', onSelect); // 點擊事件

          const glLayer = new XRWebGLLayer(xrSession, gl);
          await xrSession.updateRenderState({ baseLayer: glLayer });

          referenceSpace = await xrSession.requestReferenceSpace('local');
          log('已獲取 referenceSpace');

          // 建立 Hit Test
          const viewerSpace = await xrSession.requestReferenceSpace('viewer');
          hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });
          log('HitTestSource 已建立');

          xrSession.requestAnimationFrame(onXRFrame);

        } catch (err) {
          log('啟動 AR 失敗: ' + err.message);
          console.error(err);
        }
      }

      function onXRFrame(time, frame) {
        xrSession.requestAnimationFrame(onXRFrame);

        const pose = frame.getViewerPose(referenceSpace);
        if (!pose) return;

        // 嘗試 hit-test
        const hitTestResults = frame.getHitTestResults(hitTestSource);

        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const pose = hit.getPose(referenceSpace);

          // 顯示 reticle 提示
          reticle.visible = true;
          reticle.position.set(
            pose.transform.position.x,
            pose.transform.position.y,
            pose.transform.position.z
          );
          reticle.quaternion.set(
            pose.transform.orientation.x,
            pose.transform.orientation.y,
            pose.transform.orientation.z,
            pose.transform.orientation.w
          );
        } else {
          reticle.visible = false;
        }

        // 渲染
        for (const view of pose.views) {
          const viewport = xrSession.renderState.baseLayer.getViewport(view);
          renderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);

          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.matrix.fromArray(view.transform.inverse.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.updateMatrixWorld(true);

          renderer.render(scene, camera);
        }
      }

      function onSelect() {
        if (reticle.visible) {
          if (!cube) {
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 });
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            log('立方體已建立');
          }
          cube.position.copy(reticle.position);
          cube.quaternion.copy(reticle.quaternion);
          log('立方體已放置於', cube.position);
        } else {
          log('沒有偵測到平面，無法放置');
        }
      }

      startBtn.addEventListener('click', async () => {
        await initThree();
        await startAR();
        document.getElementById('ui').style.display = 'none';
      });
    </script>
  </body>
</html>
