<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebXR AR with Plane Detection & GLB Loading</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>

      <!-- 網頁用Console -->
  <script src="https://cdn.bootcdn.net/ajax/libs/vConsole/3.15.0/vconsole.min.js"></script>
  <script>  var vConsole = new VConsole();  </script>
  </head>
  <body style="margin:0; padding:0; overflow:hidden; background:#000;">
    <div id="ui" style="position: absolute; top: 20px; left: 20px; right: 20px; z-index: 999;">
      <button id="startAR" style="width: 100%; padding: 20px; font-size: 20px; background: #4CAF50; color: white; border: none; border-radius: 10px; cursor: pointer;">
        啟動 AR
      </button>
      
      <div style="margin-top: 10px; display: flex; gap: 10px;">
        <input type="file" id="modelUpload" accept=".glb,.gltf" style="display: none;">
        <button id="uploadBtn" style="flex: 1; padding: 15px; font-size: 16px; background: #2196F3; color: white; border: none; border-radius: 8px;">
          上傳 GLB 模型
        </button>
        <button id="resetBtn" style="flex: 1; padding: 15px; font-size: 16px; background: #ff9800; color: white; border: none; border-radius: 8px;">
          清除所有物件
        </button>
      </div>
      
      <div id="status" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.8); color: white; border-radius: 10px; font-family: Arial, sans-serif; font-size: 14px;">
        準備測試 WebXR AR...
      </div>
      
      <div id="instructions" style="margin-top: 10px; padding: 10px; background: rgba(0,100,200,0.7); color: white; border-radius: 8px; font-family: Arial, sans-serif; font-size: 13px;">
        📱 說明：點擊偵測到的平面來放置 3D 物件
      </div>
      
      <div id="debug" style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.6); color: #ccc; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto;">
        <div>WebXR AR 除錯:</div>
      </div>
    </div>

    <canvas id="canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>

    <script>
      const startBtn = document.getElementById('startAR');
      const uploadBtn = document.getElementById('uploadBtn');
      const resetBtn = document.getElementById('resetBtn');
      const modelUpload = document.getElementById('modelUpload');
      const status = document.getElementById('status');
      const debug = document.getElementById('debug');
      const canvas = document.getElementById('canvas');
      
      let gl, xrSession, hitTestSource;
      let scene, camera, renderer, reticle;
      let animationFrameId;
      let referenceSpace = null;
      let referenceSpaceAttempted = false;
      
      // 模型相關
      //ks
      let currentModel = null;
      let placedObjects = [];
      let loader = new THREE.GLTFLoader();
      let defaultModelUrl = 'src\model\test.glb'; // 預設模型檔案名
      
      // 平面偵測相關
      let detectedPlanes = [];
      let planeMeshes = [];
      
      function updateStatus(msg) {
        status.textContent = msg;
        addDebug('Status: ' + msg);
      }
      
      function addDebug(msg) {
        const div = document.createElement('div');
        div.textContent = new Date().toLocaleTimeString() + ': ' + msg;
        debug.appendChild(div);
        debug.scrollTop = debug.scrollHeight;
        console.log('[AR]', msg);
        
        if (debug.children.length > 30) {
          debug.removeChild(debug.children[1]);
        }
      }
      
      async function loadModel(url) {
        // 動態載入 GLTFLoader
        if (!loader) {
          addDebug('載入 GLTFLoader...');
          await loadGLTFLoader();
        }
        
        return new Promise((resolve, reject) => {
          addDebug('載入模型: ' + url);
          loader.load(
            url,
            (gltf) => {
              addDebug('模型載入成功');
              const model = gltf.scene;
              
              // 調整模型大小和位置
              const box = new THREE.Box3().setFromObject(model);
              const size = box.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              const scale = 0.2 / maxDim; // 調整為合適大小
              model.scale.setScalar(scale);
              
              // 將模型置中
              const center = box.getCenter(new THREE.Vector3());
              model.position.sub(center.multiplyScalar(scale));
              
              resolve(model);
            },
            (progress) => {
              const percent = Math.round((progress.loaded / progress.total) * 100);
              addDebug(`載入進度: ${percent}%`);
            },
            (error) => {
              addDebug('模型載入失敗: ' + error.message);
              reject(error);
            }
          );
        });
      }
      
      // 動態載入 GLTFLoader
      function loadGLTFLoader() {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js';
          script.onload = () => {
            if (THREE.GLTFLoader) {
              loader = new THREE.GLTFLoader();
              addDebug('GLTFLoader 載入成功');
              resolve();
            } else {
              reject(new Error('GLTFLoader 載入失敗'));
            }
          };
          script.onerror = () => reject(new Error('無法載入 GLTFLoader 腳本'));
          document.head.appendChild(script);
        });
      }
      
      function createReticle() {
        const geometry = new THREE.RingGeometry(0.02, 0.04, 32);
        const material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.8
        });
        reticle = new THREE.Mesh(geometry, material);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);
        addDebug('準星創建完成');
      }
      
      function createDefaultCube() {
        const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshLambertMaterial({ 
          color: 0xff4444,
          transparent: true,
          opacity: 0.8
        });
        const cube = new THREE.Mesh(geometry, material);
        return cube;
      }
      
      async function initThreeJS() {
        addDebug('創建 XR 兼容的 Three.js 環境...');
        
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        
        const contextAttributes = {
          alpha: true,
          antialias: true,
          xrCompatible: true
        };
        
        gl = canvas.getContext('webgl', contextAttributes) || canvas.getContext('experimental-webgl', contextAttributes);
        
        if (!gl) {
          throw new Error('無法創建 WebGL 上下文');
        }
        
        addDebug('WebGL 上下文已創建 (xrCompatible: true)');
        
        renderer = new THREE.WebGLRenderer({ 
          canvas: canvas,
          context: gl,
          alpha: true,
          antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // 創建準星
        createReticle();
        
        // 嘗試載入預設模型
        try {
          currentModel = await loadModel(defaultModelUrl);
          addDebug('預設模型載入成功');
        } catch (error) {
          addDebug('預設模型載入失敗，使用預設立方體');
          currentModel = createDefaultCube();
        }
        
        addDebug('Three.js XR 兼容初始化完成');
      }
      
      async function startAR() {
        try {
          updateStatus('檢查 WebXR 支援...');
          startBtn.disabled = true;
          
          if (!navigator.xr) {
            throw new Error('WebXR 不支援');
          }
          
          const supported = await navigator.xr.isSessionSupported('immersive-ar');
          if (!supported) {
            throw new Error('設備不支援 AR');
          }
          
          if (gl && !gl.isXRCompatible) {
            addDebug('將上下文標記為 XR 兼容...');
            await gl.makeXRCompatible();
          }
          
          addDebug('請求 AR 會話 (包含平面偵測)...');
          updateStatus('啟動 AR 會話...');
          
          xrSession = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['local'],
            optionalFeatures: ['plane-detection', 'hit-test']
          });
          addDebug('AR 會話創建成功');
          
          const glLayer = new XRWebGLLayer(xrSession, gl);
          await xrSession.updateRenderState({ baseLayer: glLayer });
          
          xrSession.addEventListener('end', cleanup);
          
          // 獲取參考空間
          referenceSpace = await xrSession.requestReferenceSpace('local');
          addDebug('獲取參考空間成功');
          
          // 設置 hit test
          try {
            hitTestSource = await xrSession.requestHitTestSource({ space: referenceSpace });
            addDebug('Hit test 設置成功');
          } catch (error) {
            addDebug('Hit test 設置失敗: ' + error.message);
          }
          
          updateStatus('AR 啟動成功！點擊平面放置物件');
          animationFrameId = xrSession.requestAnimationFrame(onXRFrame);
          
          // 添加點擊事件
          canvas.addEventListener('click', onTouch);
          
          setTimeout(() => {
            document.getElementById('ui').style.display = 'none';
          }, 4000);
          
        } catch (error) {
          updateStatus('AR 啟動失敗: ' + error.message);
          addDebug('詳細錯誤: ' + error.toString());
          startBtn.disabled = false;
        }
      }
      
      function onTouch(event) {
        if (!xrSession || !reticle.visible) return;
        
        if (currentModel) {
          const modelClone = currentModel.clone();
          modelClone.position.copy(reticle.position);
          modelClone.rotation.copy(reticle.rotation);
          
          // 隨機化顏色 (如果是預設立方體)
          if (modelClone.material && modelClone.material.color) {
            modelClone.material = modelClone.material.clone();
            modelClone.material.color.setHSL(Math.random(), 0.8, 0.6);
          }
          
          scene.add(modelClone);
          placedObjects.push(modelClone);
          
          addDebug(`放置物件 #${placedObjects.length} 在 (${reticle.position.x.toFixed(2)}, ${reticle.position.y.toFixed(2)}, ${reticle.position.z.toFixed(2)})`);
        }
      }
      
      function onXRFrame(time, frame) {
        if (!xrSession) return;
        
        animationFrameId = xrSession.requestAnimationFrame(onXRFrame);
        
        const pose = frame.getViewerPose(referenceSpace);
        
        if (pose) {
          // Hit test for reticle positioning
          if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              reticle.visible = true;
              reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
          
          // 處理平面偵測
          if (frame.detectedPlanes) {
            updateDetectedPlanes(frame.detectedPlanes);
          }
          
          // 渲染每個視圖
          for (const view of pose.views) {
            const viewport = xrSession.renderState.baseLayer.getViewport(view);
            renderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
            
            camera.projectionMatrix.fromArray(view.projectionMatrix);
            camera.matrix.fromArray(view.transform.inverse.matrix);
            camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
            camera.updateMatrixWorld(true);
            
            renderer.clear();
            renderer.render(scene, camera);
          }
        }
      }
      
      function updateDetectedPlanes(detectedPlanes) {
        // 清除舊的平面網格
        planeMeshes.forEach(mesh => scene.remove(mesh));
        planeMeshes = [];
        
        // 為每個偵測到的平面創建視覺化網格
        detectedPlanes.forEach((plane, index) => {
          const geometry = new THREE.PlaneGeometry(1, 1);
          const material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.1,
            wireframe: true
          });
          const planeMesh = new THREE.Mesh(geometry, material);
          
          // 設置平面位置和旋轉
          const pose = plane.planeSpace.getOffsetReferenceSpace(referenceSpace);
          planeMesh.matrix.fromArray(pose.transform.matrix);
          planeMesh.matrixAutoUpdate = false;
          
          scene.add(planeMesh);
          planeMeshes.push(planeMesh);
        });
      }
      
      function resetObjects() {
        placedObjects.forEach(obj => scene.remove(obj));
        placedObjects = [];
        addDebug('已清除所有放置的物件');
        updateStatus('物件已清除');
      }
      
      function cleanup() {
        if (animationFrameId) {
          xrSession?.cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        
        if (hitTestSource) {
          hitTestSource.cancel();
          hitTestSource = null;
        }
        
        canvas.removeEventListener('click', onTouch);
        
        xrSession = null;
        referenceSpace = null;
        referenceSpaceAttempted = false;
        
        startBtn.disabled = false;
        startBtn.textContent = '重新啟動 AR';
        document.getElementById('ui').style.display = 'block';
        updateStatus('AR 會話已結束');
      }
      
      // 事件監聽
      startBtn.addEventListener('click', startAR);
      resetBtn.addEventListener('click', resetObjects);
      
      uploadBtn.addEventListener('click', () => {
        modelUpload.click();
      });
      
      modelUpload.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (file) {
          try {
            await waitForGLTFLoader();
            const url = URL.createObjectURL(file);
            currentModel = await loadModel(url);
            addDebug('自訂模型載入成功: ' + file.name);
            URL.revokeObjectURL(url);
          } catch (error) {
            addDebug('自訂模型載入失敗: ' + error.message);
            alert('模型載入失敗，請檢查檔案格式');
          }
        }
      });
      
      // 初始化
      window.addEventListener('load', async () => {
        addDebug('頁面載入，初始化 WebXR AR 環境');
        addDebug('User Agent: ' + navigator.userAgent.substring(0, 50) + '...');
        
        try {
          await initThreeJS();
          updateStatus('AR 環境準備就緒');
        } catch (error) {
          updateStatus('初始化失敗: ' + error.message);
          addDebug('初始化錯誤: ' + error.toString());
        }
      });
      
      window.addEventListener('resize', () => {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
      
    </script>
  </body>
</html>