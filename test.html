<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 平面偵測</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        /* 控制面板樣式 */
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            text-align: center;
        }

        /* 按鈕樣式 */
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            touch-action: manipulation;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        /* 狀態顯示 */
        #status {
            margin: 10px 0;
            font-size: 14px;
        }

        /* 畫布容器 */
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* 偵測到的平面指示器 */
        .plane-indicator {
            position: absolute;
            border: 2px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            z-index: 500;
        }
    </style>
</head>
<body>
    <!-- 控制面板 -->
    <div id="controls">
        <h3>Three.js 平面偵測</h3>
        <button id="startBtn">開啟鏡頭偵測</button>
        <button id="stopBtn" disabled>停止偵測</button>
        <div id="status">準備就緒</div>
    </div>

    <!-- 渲染容器 -->
    <div id="container"></div>

    <!-- Three.js 函式庫 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // === 全域變數定義 ===
        let scene, camera, renderer, video, videoTexture;
        let isDetecting = false;
        let animationId;
        let detectedPlanes = []; // 儲存偵測到的平面

        // === DOM 元素獲取 ===
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');
        const container = document.getElementById('container');

        // === 平面偵測相關變數 ===
        let canvas2d, ctx2d; // 用於影像處理的2D畫布
        let edgeDetectionThreshold = 50; // 邊緣偵測閾值（可調整）

        // === 初始化Three.js場景 ===
        function initThreeJS() {
            // 建立場景
            scene = new THREE.Scene();

            // 建立攝影機
            camera = new THREE.PerspectiveCamera(
                75, // 視角
                window.innerWidth / window.innerHeight, // 寬高比
                0.1, // 近平面
                1000 // 遠平面
            );

            // 建立渲染器
            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // 透明背景
            container.appendChild(renderer.domElement);

            // 設置攝影機位置
            camera.position.z = 1;
        }

        // === 建立視訊背景平面 ===
        function createVideoPlane() {
            // 建立視訊材質
            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;

            // 建立材質
            const material = new THREE.MeshBasicMaterial({ 
                map: videoTexture,
                side: THREE.DoubleSide 
            });

            // 建立平面幾何
            const geometry = new THREE.PlaneGeometry(2, 2);
            
            // 建立網格
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = -1; // 放在背景
            
            scene.add(mesh);
        }

        // === 開啟攝影機 ===
        async function startCamera() {
            try {
                status.textContent = '正在開啟攝影機...';
                
                // 請求攝影機權限
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment', // 使用後置攝影機（適合AR應用）
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });

                // 建立video元素
                video = document.createElement('video');
                video.srcObject = stream;
                video.play();

                // 等待視訊載入
                video.addEventListener('loadedmetadata', () => {
                    // 建立用於影像處理的2D畫布
                    canvas2d = document.createElement('canvas');
                    canvas2d.width = video.videoWidth;
                    canvas2d.height = video.videoHeight;
                    ctx2d = canvas2d.getContext('2d');

                    // 建立Three.js視訊平面
                    createVideoPlane();
                    
                    // 開始渲染和偵測
                    startDetection();
                    
                    status.textContent = '偵測中...';
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                });

            } catch (error) {
                console.error('無法開啟攝影機:', error);
                status.textContent = '攝影機開啟失敗: ' + error.message;
            }
        }

        // === 停止攝影機 ===
        function stopCamera() {
            isDetecting = false;
            
            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video = null;
            }

            // 清除場景
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }

            // 清除平面指示器
            clearPlaneIndicators();

            status.textContent = '已停止偵測';
            startBtn.disabled = false;
            stopBtn.disabled = true;
        }

        // === 開始平面偵測 ===
        function startDetection() {
            isDetecting = true;
            detectPlanes();
        }

        // === 平面偵測主函數 ===
        function detectPlanes() {
            if (!isDetecting || !video || !ctx2d) return;

            // 將視訊畫面繪製到2D畫布上進行處理
            ctx2d.drawImage(video, 0, 0);
            const imageData = ctx2d.getImageData(0, 0, canvas2d.width, canvas2d.height);
            
            // 執行邊緣偵測
            const edges = detectEdges(imageData);
            
            // 尋找矩形區域（可能的平面）
            const planes = findRectangularRegions(edges);
            
            // 更新平面顯示
            updatePlaneDisplay(planes);
            
            // Three.js渲染
            renderer.render(scene, camera);
            
            // 繼續下一幀
            animationId = requestAnimationFrame(detectPlanes);
        }

        // === 邊緣偵測算法（簡化版Sobel算子） ===
        function detectEdges(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const edges = new Uint8Array(width * height);

            // Sobel算子核心
            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;

                    // 計算Sobel X和Y梯度
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const pixelIndex = ((y + i) * width + (x + j)) * 4;
                            const gray = (data[pixelIndex] + data[pixelIndex + 1] + data[pixelIndex + 2]) / 3;
                            
                            const kernelIndex = (i + 1) * 3 + (j + 1);
                            gx += gray * sobelX[kernelIndex];
                            gy += gray * sobelY[kernelIndex];
                        }
                    }

                    // 計算梯度強度
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    edges[y * width + x] = magnitude > edgeDetectionThreshold ? 255 : 0;
                }
            }

            return { data: edges, width, height };
        }

        // === 尋找矩形區域（簡化版） ===
        function findRectangularRegions(edges) {
            const planes = [];
            const { data, width, height } = edges;

            // 簡化的矩形偵測：尋找連續的水平和垂直線段
            const minPlaneSize = 50; // 最小平面大小（像素）
            
            // 這裡使用簡化的方法偵測大致的矩形區域
            // 實際應用中可以使用更複雜的算法如霍夫變換
            for (let y = 0; y < height - minPlaneSize; y += 20) {
                for (let x = 0; x < width - minPlaneSize; x += 20) {
                    if (isLikelyPlane(data, x, y, minPlaneSize, width, height)) {
                        planes.push({
                            x: x,
                            y: y,
                            width: minPlaneSize,
                            height: minPlaneSize,
                            confidence: Math.random() * 0.5 + 0.5 // 模擬信心度
                        });
                    }
                }
            }

            return planes;
        }

        // === 判斷是否為平面區域 ===
        function isLikelyPlane(edgeData, startX, startY, size, imageWidth, imageHeight) {
            let edgeCount = 0;
            let totalPixels = 0;

            // 檢查邊界區域的邊緣密度
            for (let y = startY; y < startY + size && y < imageHeight; y++) {
                for (let x = startX; x < startX + size && x < imageWidth; x++) {
                    totalPixels++;
                    if (edgeData[y * imageWidth + x] > 0) {
                        edgeCount++;
                    }
                }
            }

            // 如果邊緣密度在合理範圍內，認為可能是平面
            const edgeDensity = edgeCount / totalPixels;
            return edgeDensity > 0.1 && edgeDensity < 0.7; // 可調整參數
        }

        // === 更新平面顯示 ===
        function updatePlaneDisplay(planes) {
            // 清除之前的指示器
            clearPlaneIndicators();

            // 計算縮放比例（視訊解析度到顯示尺寸的轉換）
            const scaleX = window.innerWidth / canvas2d.width;
            const scaleY = window.innerHeight / canvas2d.height;

            // 為每個偵測到的平面創建指示器
            planes.forEach((plane, index) => {
                const indicator = document.createElement('div');
                indicator.className = 'plane-indicator';
                indicator.style.left = (plane.x * scaleX) + 'px';
                indicator.style.top = (plane.y * scaleY) + 'px';
                indicator.style.width = (plane.width * scaleX) + 'px';
                indicator.style.height = (plane.height * scaleY) + 'px';
                
                // 根據信心度調整顏色透明度
                const alpha = plane.confidence;
                indicator.style.borderColor = `rgba(0, 255, 0, ${alpha})`;
                indicator.style.backgroundColor = `rgba(0, 255, 0, ${alpha * 0.1})`;

                container.appendChild(indicator);
            });

            // 更新狀態
            status.textContent = `偵測中... 發現 ${planes.length} 個可能平面`;
        }

        // === 清除平面指示器 ===
        function clearPlaneIndicators() {
            const indicators = document.querySelectorAll('.plane-indicator');
            indicators.forEach(indicator => indicator.remove());
        }

        // === 視窗大小調整處理 ===
        function handleResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // === 事件監聽器設置 ===
        function setupEventListeners() {
            startBtn.addEventListener('click', startCamera);
            stopBtn.addEventListener('click', stopCamera);
            window.addEventListener('resize', handleResize);
        }

        // === 應用程式初始化 ===
        function init() {
            // 檢查瀏覽器支援
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                status.textContent = '此瀏覽器不支援攝影機功能';
                startBtn.disabled = true;
                return;
            }

            // 初始化Three.js
            initThreeJS();
            
            // 設置事件監聽器
            setupEventListeners();
            
            console.log('Three.js 平面偵測應用程式已初始化');
        }

        // === 應用程式啟動 ===
        // 等待頁面完全載入後初始化
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // === 錯誤處理 ===
        window.addEventListener('error', (event) => {
            console.error('應用程式錯誤:', event.error);
            status.textContent = '發生錯誤: ' + event.error.message;
        });

    </script>
</body>
</html>