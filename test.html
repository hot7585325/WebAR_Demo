<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Manual WebXR AR - No Reference Space</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  </head>
  <body style="margin:0; padding:0; overflow:hidden; background:#000;">
    <div id="ui" style="position: absolute; top: 20px; left: 20px; right: 20px; z-index: 999;">
      <button id="startAR" style="width: 100%; padding: 20px; font-size: 20px; background: #4CAF50; color: white; border: none; border-radius: 10px; cursor: pointer;">
        啟動 AR
      </button>
      
      <div id="status" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.8); color: white; border-radius: 10px; font-family: Arial, sans-serif; font-size: 14px;">
        準備測試手動 WebXR...
      </div>
      
      <div id="debug" style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.6); color: #ccc; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto;">
        <div>手動 WebXR 除錯:</div>
      </div>
    </div>

    <canvas id="canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>

    <script>
      const startBtn = document.getElementById('startAR');
      const status = document.getElementById('status');
      const debug = document.getElementById('debug');
      const canvas = document.getElementById('canvas');
      
      let gl, xrSession;
      let scene, camera, renderer, cube;
      let animationFrameId;
      
      function updateStatus(msg) {
        status.textContent = msg;
        addDebug('Status: ' + msg);
      }
      
      function addDebug(msg) {
        const div = document.createElement('div');
        div.textContent = new Date().toLocaleTimeString() + ': ' + msg;
        debug.appendChild(div);
        debug.scrollTop = debug.scrollHeight;
        console.log('[Manual AR]', msg);
        
        if (debug.children.length > 25) {
          debug.removeChild(debug.children[1]);
        }
      }
      
      function initThreeJS() {
        addDebug('手動初始化 Three.js（不使用 XR）...');
        
        // 創建場景
        scene = new THREE.Scene();
        
        // 創建相機
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.z = 0;
        
        // 創建渲染器，但不啟用 XR
        renderer = new THREE.WebGLRenderer({ 
          canvas: canvas,
          alpha: true,
          antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // 重要：不設置 renderer.xr.enabled = true
        
        // 獲取 WebGL 上下文
        gl = renderer.getContext();
        
        // 創建一個簡單的立方體
        const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshBasicMaterial({ 
          color: 0xff0000,
          wireframe: false
        });
        cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 0, -0.3);
        scene.add(cube);
        
        // 添加光源
        const light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);
        
        addDebug('Three.js 手動初始化完成');
      }
      
      async function startAR() {
        try {
          updateStatus('檢查 WebXR 支援...');
          startBtn.disabled = true;
          
          if (!navigator.xr) {
            throw new Error('WebXR 不支援');
          }
          
          const supported = await navigator.xr.isSessionSupported('immersive-ar');
          if (!supported) {
            throw new Error('設備不支援 AR');
          }
          
          addDebug('請求最簡單的 AR 會話...');
          updateStatus('啟動 AR 會話...');
          
          // 請求最基本的 AR 會話
          xrSession = await navigator.xr.requestSession('immersive-ar');
          addDebug('AR 會話創建成功');
          
          updateStatus('手動設置 WebGL 層...');
          
          // 手動設置 WebXR 層，不通過 Three.js
          const glLayer = new XRWebGLLayer(xrSession, gl);
          await xrSession.updateRenderState({ baseLayer: glLayer });
          
          addDebug('WebGL 層設置完成');
          
          // 會話結束監聽
          xrSession.addEventListener('end', () => {
            addDebug('AR 會話結束');
            cleanup();
          });
          
          updateStatus('開始手動 AR 渲染循環...');
          addDebug('啟動手動渲染（完全跳過參考空間）');
          
          // 手動啟動渲染循環
          animationFrameId = xrSession.requestAnimationFrame(onXRFrame);
          
          updateStatus('AR 手動模式啟動成功！');
          addDebug('手動 AR 渲染正在運行');
          
          setTimeout(() => {
            document.getElementById('ui').style.display = 'none';
          }, 4000);
          
        } catch (error) {
          updateStatus('AR 啟動失敗: ' + error.message);
          addDebug('詳細錯誤: ' + error.toString());
          addDebug('錯誤堆疊: ' + (error.stack || '無堆疊資訊'));
          startBtn.disabled = false;
        }
      }
      
      function onXRFrame(time, frame) {
        if (!xrSession) return;
        
        // 請求下一幀
        animationFrameId = xrSession.requestAnimationFrame(onXRFrame);
        
        // 簡單動畫
        if (cube) {
          cube.rotation.x += 0.005;
          cube.rotation.y += 0.01;
        }
        
        // 獲取會話的渲染狀態
        const session = xrSession;
        const pose = frame.getViewerPose(null); // 不使用參考空間，直接傳 null
        
        if (pose) {
          const view = pose.views[0];
          
          // 設置視口
          const viewport = session.renderState.baseLayer.getViewport(view);
          renderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
          
          // 更新相機矩陣
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.matrix.fromArray(view.transform.inverse.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.updateMatrixWorld(true);
          
          // 渲染場景
          renderer.render(scene, camera);
        } else {
          // 如果無法獲取 pose，就使用預設視圖渲染
          renderer.render(scene, camera);
        }
      }
      
      function cleanup() {
        if (animationFrameId) {
          if (xrSession) {
            xrSession.cancelAnimationFrame(animationFrameId);
          }
          animationFrameId = null;
        }
        
        xrSession = null;
        startBtn.disabled = false;
        startBtn.textContent = '重新啟動 AR';
        document.getElementById('ui').style.display = 'block';
        updateStatus('AR 會話已結束');
      }
      
      // 事件監聽
      startBtn.addEventListener('click', startAR);
      
      // 初始化
      window.addEventListener('load', () => {
        addDebug('頁面載入，準備手動 WebXR 模式');
        addDebug('User Agent: ' + navigator.userAgent.substring(0, 50) + '...');
        addDebug('Protocol: ' + window.location.protocol);
        initThreeJS();
        updateStatus('手動模式準備就緒');
      });
      
      // 視窗調整
      window.addEventListener('resize', () => {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
      
    </script>
  </body>
</html>