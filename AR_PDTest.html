<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js ar - GLTF model placement</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			
			a {
				color: #f00;
			}
			
			#status {
				position: absolute;
				top: 60px;
				left: 10px;
				z-index: 100;
				background: rgba(0,0,0,0.7);
				padding: 10px;
				border-radius: 5px;
				font-size: 14px;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> ar - GLTF model placement<br/>
			點擊螢幕在偵測到的平面上放置 3D 模型
		</div>

		<div id="status">載入中...</div>

		<!-- VConsole for debugging -->
		<script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
		<script>
			var vConsole = new window.VConsole();
			console.log('VConsole initialized');
		</script>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

		<script type="module">
			// Import modules from CDN
			import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/loaders/GLTFLoader.js';
			import { ARButton } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/ARButton.js';

			console.log('Modules imported successfully');

			let container;
			let camera, scene, renderer;
			let controller1, controller2;
			let reticle;
			let hitTestSource = null;
			let hitTestSourceRequested = false;
			
			// GLTF related variables
			let gltfLoader;
			let loadedModel = null;
			let isModelLoaded = false;

			// 在這裡修改您的 GLTF 模型 URL
			const GLTF_MODEL_URL = 'src\model\ar_hotpoint.glb';
			// 其他範例:
			// const GLTF_MODEL_URL = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF/Duck.gltf';
			// const GLTF_MODEL_URL = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Avocado/glTF/Avocado.gltf';

			init();

			function updateStatus(message, color = 'white') {
				const statusDiv = document.getElementById('status');
				statusDiv.textContent = message;
				statusDiv.style.color = color;
				console.log('Status:', message);
			}

			function init() {
				console.log('Initializing AR scene...');
				
				container = document.createElement('div');
				document.body.appendChild(container);

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

				// Lighting setup
				const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
				scene.add(ambientLight);

				const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
				directionalLight.position.set(0, 1, 1);
				directionalLight.castShadow = true;
				scene.add(directionalLight);

				const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 0.3);
				scene.add(hemisphereLight);

				renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setAnimationLoop(animate);
				renderer.xr.enabled = true;
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				container.appendChild(renderer.domElement);

				// Create AR Button
				const arButton = ARButton.createButton(renderer, { 
					requiredFeatures: ['hit-test'],
					optionalFeatures: ['dom-overlay'],
					domOverlay: { root: document.body }
				});
				document.body.appendChild(arButton);

				// Initialize GLTF loader
				gltfLoader = new GLTFLoader();
				console.log('GLTFLoader initialized');

				function onSelect() {
					console.log('Select event triggered');
					console.log('Reticle visible:', reticle.visible);
					console.log('Model loaded:', isModelLoaded);
					console.log('Loaded model:', loadedModel);
					
					if (reticle.visible && isModelLoaded && loadedModel) {
						console.log('Placing model...');
						
						try {
							// Clone the loaded model
							const modelClone = loadedModel.clone();
							console.log('Model cloned successfully');
							
							// Get position from reticle
							const position = new THREE.Vector3();
							const quaternion = new THREE.Quaternion();
							const scale = new THREE.Vector3();
							reticle.matrix.decompose(position, quaternion, scale);
							
							console.log('Reticle position:', position);
							
							// Set position and rotation
							modelClone.position.copy(position);
							modelClone.quaternion.copy(quaternion);
							
							// Set appropriate scale
							modelClone.scale.setScalar(0.5);
							
							// Add to scene
							scene.add(modelClone);
							console.log('Model added to scene');
							
							updateStatus(`模型已放置! 場景中共有 ${scene.children.length} 個物件`, 'lightgreen');
							
						} catch (error) {
							console.error('Error placing model:', error);
							updateStatus('放置模型時發生錯誤', 'red');
						}
					} else {
						console.log('Cannot place model - conditions not met');
						if (!reticle.visible) console.log('- Reticle not visible');
						if (!isModelLoaded) console.log('- Model not loaded');
						if (!loadedModel) console.log('- No loaded model available');
					}
				}

				controller1 = renderer.xr.getController(0);
				controller1.addEventListener('select', onSelect);
				scene.add(controller1);

				controller2 = renderer.xr.getController(1);
				controller2.addEventListener('select', onSelect);
				scene.add(controller2);

				// Create reticle (targeting circle)
				reticle = new THREE.Mesh(
					new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
					new THREE.MeshBasicMaterial({ 
						color: 0x00ff00, 
						transparent: true, 
						opacity: 0.7,
						side: THREE.DoubleSide
					})
				);
				reticle.matrixAutoUpdate = false;
				reticle.visible = false;
				scene.add(reticle);
				console.log('Reticle created');

				window.addEventListener('resize', onWindowResize);

				// Load the GLTF model
				loadGLTFModel();
			}

			function loadGLTFModel() {
				console.log('Loading GLTF model from:', GLTF_MODEL_URL);
				updateStatus('載入模型中...', 'yellow');

				gltfLoader.load(
					GLTF_MODEL_URL,
					function(gltf) {
						console.log('GLTF loaded successfully:', gltf);
						
						loadedModel = gltf.scene;
						isModelLoaded = true;
						
						// Get model bounding box for scaling reference
						const box = new THREE.Box3().setFromObject(loadedModel);
						const size = box.getSize(new THREE.Vector3());
						const maxDimension = Math.max(size.x, size.y, size.z);
						
						console.log('Model size:', size);
						console.log('Max dimension:', maxDimension);
						
						updateStatus(`模型載入成功! 準備放置`, 'lightgreen');
						
						// Traverse and log model structure
						loadedModel.traverse((child) => {
							if (child.isMesh) {
								console.log('Mesh found:', child.name, child.geometry, child.material);
							}
						});
						
					},
					function(progress) {
						const percent = (progress.loaded / progress.total * 100) || 0;
						console.log('Loading progress:', percent + '%');
						updateStatus(`載入中... ${percent.toFixed(1)}%`, 'yellow');
					},
					function(error) {
						console.error('Error loading GLTF:', error);
						updateStatus('模型載入失敗!', 'red');
						isModelLoaded = false;
					}
				);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate(timestamp, frame) {
				if (frame) {
					const referenceSpace = renderer.xr.getReferenceSpace();
					const session = renderer.xr.getSession();

					if (hitTestSourceRequested === false) {
						session.requestReferenceSpace('viewer').then(function(referenceSpace) {
							session.requestHitTestSource({ space: referenceSpace }).then(function(source) {
								hitTestSource = source;
								console.log('Hit test source acquired');
							});
						});

						session.addEventListener('end', function() {
							hitTestSourceRequested = false;
							hitTestSource = null;
							console.log('AR session ended');
						});

						hitTestSourceRequested = true;
					}

					if (hitTestSource) {
						const hitTestResults = frame.getHitTestResults(hitTestSource);

						if (hitTestResults.length) {
							const hit = hitTestResults[0];
							reticle.visible = true;
							reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
						} else {
							reticle.visible = false;
						}
					}
				}

				renderer.render(scene, camera);
			}

			// Add click event for non-XR testing
			window.addEventListener('click', function(event) {
				if (!renderer.xr.isPresenting) {
					console.log('Click event (non-XR mode)');
					// For testing outside AR
				}
			});

		</script>
	</body>
</html>